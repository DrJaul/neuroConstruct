/**
 *  neuroConstruct
 *  Software for developing large scale 3D networks of biologically realistic neurons
 * 
 *  Copyright (c) 2009 Padraig Gleeson
 *  UCL Department of Neuroscience, Physiology and Pharmacology
 *
 *  Development of this software was made possible with funding from the
 *  Medical Research Council and the Wellcome Trust
 *  
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.

 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package ucl.physiol.neuroconstruct.cell.converters;

import java.io.*;
import java.util.*;
import javax.vecmath.*;

import ucl.physiol.neuroconstruct.cell.*;
import ucl.physiol.neuroconstruct.cell.utils.*;
import ucl.physiol.neuroconstruct.utils.*;

/**
 *
 * A class for importing Amira morphology files (.am files)
 * NOTE: only a limited subset of amira files supported. Initial implementation based on FlyCircuit Amira files:
 * http://www.flycircuit.tw
 *
 * @author Padraig Gleeson
 *  
 *
 */

public class AmiraReader extends FormatImporter
{
    private static ClassLogger logger = new ClassLogger("AmiraReader");
    


    private float defaultRadius = 2f;

    public AmiraReader()
    {
        super("AmiraReader",
                            "Importer of Amira files",
                            new String[]{".am"});

    }


    public Cell loadFromMorphologyFile(File morphologyFile, String name) throws MorphologyException
    {
        logger.logComment("Parsing file: " + morphologyFile);
        Cell cell = new Cell();
        cell.setInstanceName(name);

        try
        {
            Reader in = new FileReader(morphologyFile);
            BufferedReader lineReader = new BufferedReader(in);

            StringBuilder description = new StringBuilder("Cell morphology generated by neuroConstruct from file: "
                                                        + morphologyFile.getName()
                                                        + "\n");

            String nextLine = null;
            int lineCount = 0;

            
            boolean inVertices = false;
            boolean inLines = false;
            String verticesKey = null;
            String linesKey = null;

            ArrayList<Point3f> vertices = new ArrayList<Point3f>();
            int secIndex = 0;
            int segIndex = 0;
            Vector<Segment> segs = cell.getAllSegments();

            while ( (nextLine = lineReader.readLine()) != null)
            {
                lineCount++;
                nextLine = nextLine.trim();
                
                logger.logComment("Looking at line num " + lineCount + ": " + nextLine, true);

                
                if (nextLine.startsWith("#"))
                {
                    logger.logComment("Comment: " + nextLine);
                    if (nextLine.length()>2)
                    description.append(nextLine.substring("# ".length())+"\n");
                }
                else if (nextLine.length()==0)
                {
                    logger.logComment("Empty line...");
                }
                else if (nextLine.startsWith("define "))
                {
                    // ...
                }
                else if (nextLine.startsWith("Vertices "))
                {
                    verticesKey = nextLine.substring(nextLine.indexOf("=")+1).trim();
                }
                else if (nextLine.startsWith("Lines "))
                {
                    linesKey = nextLine.substring(nextLine.indexOf("=")+1).trim();
                }
                else if (nextLine.equals(linesKey))
                {
                    inLines = true;
                    inVertices = false;
                }
                else if (nextLine.equals(verticesKey))
                {
                    inVertices = true;
                    inLines = false;
                }
                else
                {
                    String[] items = nextLine.split("\\s+");
                    if (inVertices)
                    {
                        Point3f p3 = new Point3f(Float.parseFloat(items[0]),Float.parseFloat(items[1]),Float.parseFloat(items[2]));
                        vertices.add(p3);
                    }
                    else if (inLines)
                    {
                        Point3f p0 = vertices.get(0);
                        Section sec = new Section("Sec_"+secIndex);
                        if (secIndex==0)
                        {
                            sec.addToGroup(Section.SOMA_GROUP);
                        }
                        else
                        {
                            sec.addToGroup(Section.DENDRITIC_GROUP);
                        }
                        secIndex++;

                        sec.setStartPointPositionX(p0.x);
                        sec.setStartPointPositionY(p0.y);
                        sec.setStartPointPositionZ(p0.z);
                        sec.setStartRadius(defaultRadius);

                        for (int i=1;i<items.length-1;i++)
                        {
                            Point3f pn = vertices.get(Integer.parseInt(items[i]));
                            Segment seg = new Segment();
                            seg.setSection(sec);
                            seg.setSegmentId(segIndex);
                            seg.setSegmentName("Seg_"+segIndex);
                            seg.setEndPointPositionX(pn.x);
                            seg.setEndPointPositionY(pn.y);
                            seg.setEndPointPositionZ(pn.z);
                            seg.setRadius(defaultRadius);
                            segs.add(seg);
                            segIndex++;

                        }
                    }
                    else
                    {
                        logger.logComment("Ignoring: " + nextLine+ ", verticesKey: "+verticesKey+", inVertices: "+inVertices, true);
                    }
                }

            }
            if (lineCount == 0)
            {
                GuiUtils.showErrorMessage(logger, "Error. No lines found in file: " + morphologyFile, null, null);
            }

            Segment firstSeg = null;
            
            cell.setCellDescription(GeneralUtils.replaceAllTokens(description.toString(), "&", "and"));


            logger.logComment("Completed parsing of file: " + morphologyFile+", has "+vertices.size()+" vertices", true);
        }
        catch (IOException e)
        {
            GuiUtils.showErrorMessage(logger, "Error: " + e.getMessage(), e, null);
            return null;
        }
        

        return cell;
    }

    
    
    

    
    
    private class PointInfo
    {
        protected Point3f xyz = null;
        protected int index = -1;
        
        public PointInfo(Point3f xyz, 
                          int index)
        {
            this.xyz = xyz;
            this.index = index;
        }
        
        @Override
        public String toString()
        {
            return "PointInfo: ("+index+")"
            +xyz+"\n";
        }
    }

    public static void main(String[] args)
    {

        try
        {
            File f = (new File("../models/amiraTest/GH146MARCM-M000005_seg001_linesetClear.am")).getCanonicalFile();
            
            logger.logComment("loading cell...");
            GeneralUtils.timeCheck("Before loading Amira");


            AmiraReader amReader = new AmiraReader();

            Cell amCell = amReader.loadFromMorphologyFile(f, "AmCell0");


            GeneralUtils.timeCheck("After loading Amira");

            System.out.println(CellTopologyHelper.printDetails(amCell, null));

            System.out.println(CellTopologyHelper.getValidityStatus(amCell));
            




        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
    }

}
